"use strict";(self["webpackChunksuperhero_wallet"]=self["webpackChunksuperhero_wallet"]||[]).push([[2466],{79740:(e,t,o)=>{o.d(t,{NZ:()=>S,Ay:()=>x});var i=o(72243),r=o(39788),s=o(30978),n=o(92426),a=o(20345),c=o(14387),d=o(85334);const h=({address:e},t,o)=>{var i,r;const d=null===o||void 0===o?void 0:o.topics,h=null!==(i=null===o||void 0===o?void 0:o.filter)&&void 0!==i?i:{},l={};if((0,c.uy)(null===o||void 0===o?void 0:o.fromBlock)||(l.fromBlock=(0,c.GP)(s.jn.properties.number,null===o||void 0===o?void 0:o.fromBlock,{number:a.M$.HEX,bytes:a.QR.HEX})),(0,c.uy)(null===o||void 0===o?void 0:o.toBlock)||(l.toBlock=(0,c.GP)(s.jn.properties.number,null===o||void 0===o?void 0:o.toBlock,{number:a.M$.HEX,bytes:a.QR.HEX})),d&&Array.isArray(d))l.topics=[...d];else if(l.topics=[],!t||t.anonymous||[s.CQ,"allEvents"].includes(t.name)||l.topics.push(null!==(r=t.signature)&&void 0!==r?r:(0,n.T3)((0,n.Bv)(t))),![s.CQ,"allEvents"].includes(t.name)&&t.inputs)for(const s of t.inputs){if(!s.indexed)continue;const e=h[s.name];e?Array.isArray(e)?l.topics.push(e.map(e=>(0,n.yF)(s.type,e))):"string"===s.type?l.topics.push((0,c.So)(e)):l.topics.push((0,n.yF)(s.type,e)):l.topics.push(null)}return l.topics.length||delete l.topics,e&&(l.address=e.toLowerCase()),l},l=(e,t,o)=>{const i=Array.isArray(e.inputs)?e.inputs.length:0;if(e.inputs&&i!==t.length)throw new r.SNI(`The number of arguments is not matching the methods required number. You need to pass ${i} arguments.`);let s;if(s=e.inputs?(0,n.ve)(Array.isArray(e.inputs)?e.inputs:[],t).replace("0x",""):(0,n.lN)(t).replace("0x",""),(0,n.ry)(e)){if(!o)throw new r.SNI("The contract has no contract data option set. This is necessary to append the constructor parameters.");return o.startsWith("0x")?`${o}${s}`:`0x${o}${s}`}return`${(0,n.fY)(e)}${s}`};class u extends i.tn{constructor(e,t){super(e,t),this.address=e.address,this.topics=e.topics,this.abi=e.abi,this.jsonInterface=e.jsonInterface}_buildSubscriptionParams(){return["logs",{address:this.address,topics:this.topics}]}formatSubscriptionResult(e){return(0,s.Nk)(this.abi,e,this.jsonInterface,super.returnFormat)}}Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));const f=(e,t,o,i)=>{var r,s;const n={};return(0,c.uy)(e.data)&&"both"!==i||(n.data=l(t,o,null!==(r=e.data)&&void 0!==r?r:e.input)),(0,c.uy)(e.input)&&"both"!==i||(n.input=l(t,o,null!==(s=e.input)&&void 0!==s?s:e.data)),(0,c.uy)(n.input)&&(0,c.uy)(n.data)&&(n[i]=l(t,o)),{data:n.data,input:n.input}},m=({abi:e,params:t,options:o,contractOptions:i})=>{var s,n,a;const d=null!==(a=null!==(n=null!==(s=null===o||void 0===o?void 0:o.input)&&void 0!==s?s:null===o||void 0===o?void 0:o.data)&&void 0!==n?n:i.input)&&void 0!==a?a:i.data;if(!d&&!(null===o||void 0===o?void 0:o.to)&&!i.address)throw new r.SNI("Contract address not specified");if(!(null===o||void 0===o?void 0:o.from)&&!i.from)throw new r.SNI('Contract "from" address not specified');let h=(0,c.D9)({to:i.address,gas:i.gas,gasPrice:i.gasPrice,from:i.from,input:i.input,maxPriorityFeePerGas:i.maxPriorityFeePerGas,maxFeePerGas:i.maxFeePerGas,data:i.data},o);const l=f(h,e,t,null===o||void 0===o?void 0:o.dataInputFill);return h=Object.assign(Object.assign({},h),{data:l.data,input:l.input}),h},p=({abi:e,params:t,options:o,contractOptions:i})=>{if(!(null===o||void 0===o?void 0:o.to)&&!i.address)throw new r.SNI("Contract address not specified");let s=(0,c.D9)({to:i.address,gas:i.gas,gasPrice:i.gasPrice,from:i.from,input:i.input,maxPriorityFeePerGas:i.maxPriorityFeePerGas,maxFeePerGas:i.maxFeePerGas,data:i.data},o);const n=f(s,e,t,null===o||void 0===o?void 0:o.dataInputFill);return s=Object.assign(Object.assign({},s),{data:n.data,input:n.input}),s},g=({abi:e,params:t,options:o,contractOptions:i})=>{let r=(0,c.D9)({to:i.address,gas:i.gas,gasPrice:i.gasPrice,from:i.from,input:i.input,data:i.data},o);const s=f(r,e,t,null===o||void 0===o?void 0:o.dataInputFill);return r=Object.assign(Object.assign({},r),{data:s.data,input:s.input}),r},v=e=>"object"===typeof e&&!(0,c.uy)(e)&&0!==Object.keys(e).length&&!(0,c.nF)(e),b=({abi:e,params:t,options:o,contractOptions:i})=>{if(!(null===o||void 0===o?void 0:o.to)&&!i.address)throw new r.SNI("Contract address not specified");if(!(null===o||void 0===o?void 0:o.from)&&!i.from)throw new r.SNI('Contract "from" address not specified');let s=(0,c.D9)({to:i.address,gas:i.gas,gasPrice:i.gasPrice,from:i.from,input:i.input,maxPriorityFeePerGas:i.maxPriorityFeePerGas,maxFeePerGas:i.maxFeePerGas,data:i.data},o);const n=f(s,e,t,null===o||void 0===o?void 0:o.dataInputFill);return s=Object.assign(Object.assign({},s),{data:n.data,input:n.input}),s};var y=function(e,t,o,i){function r(e){return e instanceof o?e:new o(function(t){t(e)})}return new(o||(o=Promise))(function(o,s){function n(e){try{c(i.next(e))}catch(t){s(t)}}function a(e){try{c(i["throw"](e))}catch(t){s(t)}}function c(e){e.done?o(e.value):r(e.value).then(n,a)}c((i=i.apply(e,t||[])).next())})};class k{_contractMethodDeploySend(e){const t={transactionResolver:e=>{if(e.status===BigInt(0))throw new r.SNI("code couldn't be stored",e);const t=this.parent.clone();return t.options.address=e.contractAddress,t},contractAbi:this.parent.options.jsonInterface,checkRevertBeforeSending:!1};return(0,d.uy)(this.parent.getTransactionMiddleware())?(0,s.vD)(this.parent,e,this.parent.defaultReturnFormat,t):(0,s.vD)(this.parent,e,this.parent.defaultReturnFormat,t,this.parent.getTransactionMiddleware())}constructor(e,t){this.parent=e,this.deployOptions=t;const{args:o,abi:i,contractOptions:r,deployData:s}=this.calculateDeployParams();this.args=o,this.constructorAbi=i,this.contractOptions=r,this.deployData=s}send(e){const t=Object.assign({},e),o=this.populateTransaction(t);return this._contractMethodDeploySend(o)}populateTransaction(e){var t,o;const i=Object.assign(Object.assign({},this.contractOptions),{from:null!==(o=null!==(t=this.contractOptions.from)&&void 0!==t?t:this.parent.defaultAccount)&&void 0!==o?o:void 0}),r=m({abi:this.constructorAbi,params:this.args,options:Object.assign(Object.assign({},e),{dataInputFill:this.parent.contractDataInputFill}),contractOptions:i});return r.dataInputFill&&delete r.dataInputFill,r}calculateDeployParams(){var e,t,o,i,s,n;let d=this.parent.options.jsonInterface.find(e=>"constructor"===e.type);d||(d={type:"constructor",stateMutability:""});const h=(0,c.GP)({format:"bytes"},null!==(t=null===(e=this.deployOptions)||void 0===e?void 0:e.input)&&void 0!==t?t:this.parent.options.input,a.Hh),l=(0,c.GP)({format:"bytes"},null!==(i=null===(o=this.deployOptions)||void 0===o?void 0:o.data)&&void 0!==i?i:this.parent.options.data,a.Hh);if((!h||"0x"===h.trim())&&(!l||"0x"===l.trim()))throw new r.SNI("contract creation without any data provided.");const u=null!==(n=null===(s=this.deployOptions)||void 0===s?void 0:s.arguments)&&void 0!==n?n:[],f=Object.assign(Object.assign({},this.parent.options),{input:h,data:l}),m=null!==h&&void 0!==h?h:l;return{args:u,abi:d,contractOptions:f,deployData:m}}estimateGas(e){return y(this,arguments,void 0,function*(e,t=this.parent.defaultReturnFormat){const o=Object.assign({},e);return this.parent.contractMethodEstimateGas({abi:this.constructorAbi,params:this.args,returnFormat:t,options:o,contractOptions:this.contractOptions})})}encodeABI(){return l(this.constructorAbi,this.args,(0,c.GP)({format:"bytes"},this.deployData,this.parent.defaultReturnFormat))}decodeData(e){return Object.assign(Object.assign({},(0,n.bQ)(this.constructorAbi,e.replace(this.deployData,""),!1)),{__method__:this.constructorAbi.type})}}var I=function(e,t,o,i){function r(e){return e instanceof o?e:new o(function(t){t(e)})}return new(o||(o=Promise))(function(o,s){function n(e){try{c(i.next(e))}catch(t){s(t)}}function a(e){try{c(i["throw"](e))}catch(t){s(t)}}function c(e){e.done?o(e.value):r(e.value).then(n,a)}c((i=i.apply(e,t||[])).next())})};class E extends i.Kh{constructor(e,t){super(e.requestManager,e.registeredSubscriptions),this.parentContract=t}subscribe(e,t){const o=Object.create(null,{subscribe:{get:()=>super.subscribe}});return I(this,arguments,void 0,function*(e,t,i=a.Hh){return o.subscribe.call(this,e,null!==t&&void 0!==t?t:this.parentContract.options,i)})}}var P=function(e,t,o,i){function r(e){return e instanceof o?e:new o(function(t){t(e)})}return new(o||(o=Promise))(function(o,s){function n(e){try{c(i.next(e))}catch(t){s(t)}}function a(e){try{c(i["throw"](e))}catch(t){s(t)}}function c(e){e.done?o(e.value):r(e.value).then(n,a)}c((i=i.apply(e,t||[])).next())})};const w={logs:u,newHeads:s.fJ,newBlockHeaders:s.fJ};class S extends i.bl{get subscriptionManager(){return this._subscriptionManager}constructor(e,t,o,s,n){var a,h,l;const u=(0,c.nF)(t)?t:(0,c.nF)(o)?o:void 0;let f,m;if(f=v(t)?t:v(o)?o:s,m="object"===typeof t&&"provider"in t?t.provider:"object"===typeof o&&"provider"in o?o.provider:"object"===typeof s&&"provider"in s?s.provider:S.givenProvider,super(Object.assign(Object.assign({},f),{provider:m,registeredSubscriptions:w})),this.syncWithContext=!1,this._functions={},this._subscriptionManager=new E(super.subscriptionManager,this),(null===f||void 0===f?void 0:f.wallet)&&(this._wallet=f.wallet),(null===f||void 0===f?void 0:f.accountProvider)&&(this._accountProvider=f.accountProvider),!(0,d.uy)(u)&&!(0,d.uy)(u.data)&&!(0,d.uy)(u.input)&&"both"!==this.config.contractDataInputFill)throw new r.SC6({data:u.data,input:u.input});this._overloadedMethodAbis=new Map;const p=(0,c.kY)(s)?s:(0,c.kY)(o)?o:null!==n&&void 0!==n?n:this.defaultReturnFormat,g="string"===typeof t?t:void 0;this.config.contractDataInputFill=null!==(a=null===u||void 0===u?void 0:u.dataInputFill)&&void 0!==a?a:this.config.contractDataInputFill,this._parseAndSetJsonInterface(e,p),this.defaultReturnFormat!==p&&(this.defaultReturnFormat=p),(0,d.uy)(g)||this._parseAndSetAddress(g,p),this.options={address:g,jsonInterface:this._jsonInterface,gas:null!==(h=null===u||void 0===u?void 0:u.gas)&&void 0!==h?h:null===u||void 0===u?void 0:u.gasLimit,gasPrice:null===u||void 0===u?void 0:u.gasPrice,from:null===u||void 0===u?void 0:u.from,input:null===u||void 0===u?void 0:u.input,data:null===u||void 0===u?void 0:u.data},this.syncWithContext=null!==(l=null===u||void 0===u?void 0:u.syncWithContext)&&void 0!==l&&l,f instanceof i.bl&&this.subscribeToContextEvents(f),Object.defineProperty(this.options,"address",{set:e=>this._parseAndSetAddress(e,p),get:()=>this._address}),Object.defineProperty(this.options,"jsonInterface",{set:e=>this._parseAndSetJsonInterface(e,p),get:()=>this._jsonInterface}),f instanceof i.bl&&f.on(i.AL.CONFIG_CHANGE,e=>{this.setConfig({[e.name]:e.newValue})})}setTransactionMiddleware(e){this.transactionMiddleware=e}getTransactionMiddleware(){return this.transactionMiddleware}get events(){return this._events}get methods(){return this._methods}clone(){let e;return e=this.options.address?new S([...this._jsonInterface,...this._errorsInterface],this.options.address,{gas:this.options.gas,gasPrice:this.options.gasPrice,from:this.options.from,input:this.options.input,data:this.options.data,provider:this.currentProvider,syncWithContext:this.syncWithContext,dataInputFill:this.config.contractDataInputFill},this.getContextObject()):new S([...this._jsonInterface,...this._errorsInterface],{gas:this.options.gas,gasPrice:this.options.gasPrice,from:this.options.from,input:this.options.input,data:this.options.data,provider:this.currentProvider,syncWithContext:this.syncWithContext,dataInputFill:this.config.contractDataInputFill},this.getContextObject()),this.context&&e.subscribeToContextEvents(this.context),e}deploy(e){return new k(this,e)}getPastEvents(e,t,o){return P(this,void 0,void 0,function*(){var i;const n="string"===typeof e?e:s.CQ,a="string"===typeof e||(0,c.kY)(e)?(0,c.kY)(t)?{}:t:e,d=(0,c.kY)(e)?e:(0,c.kY)(t)?t:null!==o&&void 0!==o?o:this.defaultReturnFormat,l="allEvents"===n||n===s.CQ?s.bV:this._jsonInterface.find(e=>"name"in e&&e.name===n);if(!l)throw new r.SNI(`Event ${String(n)} not found.`);const{fromBlock:u,toBlock:f,topics:m,address:p}=h(this.options,l,null!==a&&void 0!==a?a:{}),g=yield(0,s.ao)(this,{fromBlock:u,toBlock:f,topics:m,address:p},d),v=g?g.map(e=>"string"===typeof e?e:(0,s.Nk)(l,e,this._jsonInterface,d)):[],b=null!==(i=null===a||void 0===a?void 0:a.filter)&&void 0!==i?i:{},y=Object.keys(b);return y.length>0?v.filter(e=>"string"===typeof e||y.every(t=>{var o;if(Array.isArray(b[t]))return b[t].some(o=>String(e.returnValues[t]).toUpperCase()===String(o).toUpperCase());const i=null===(o=l.inputs)||void 0===o?void 0:o.filter(e=>e.name===t)[0];if((null===i||void 0===i?void 0:i.indexed)&&"string"===i.type){const o=(0,c.So)(b[t]);if(o===String(e.returnValues[t]))return!0}return String(e.returnValues[t]).toUpperCase()===String(b[t]).toUpperCase()})):v})}_parseAndSetAddress(e,t=this.defaultReturnFormat){this._address=e?(0,c.BA)((0,c.GP)({format:"address"},e,t)):e}decodeMethodData(e){const t=e.slice(0,10),o=this._jsonInterface.filter(e=>"error"!==e.type),i=o.find(e=>t===(0,n.fY)((0,n.Bv)(e)));if(!i)throw new r.SNI(`The ABI for the provided method signature ${t} was not found.`);return(0,n.bQ)(i,e)}_parseAndSetJsonInterface(e,t=this.defaultReturnFormat){var o,i;this._functions={},this._methods={},this._events={};let r=[];const a=e.filter(e=>"error"!==e.type),c=e.filter(e=>(0,n.VW)(e));for(const s of a){const e=Object.assign(Object.assign({},s),{signature:""});if((0,n.zH)(e)){const t=(0,n.Bv)(e),r=(0,n.fY)(t);e.methodNameWithInputs=t,e.signature=r,e.constant="view"===e.stateMutability||"pure"===e.stateMutability||e.constant,e.payable="payable"===e.stateMutability||e.payable,this._overloadedMethodAbis.set(e.name,[...null!==(o=this._overloadedMethodAbis.get(e.name))&&void 0!==o?o:[],e]);const s=null!==(i=this._overloadedMethodAbis.get(e.name))&&void 0!==i?i:[],a=this._createContractMethod(s,c),d=this._createContractMethod(s,c,!0);this._functions[t]={signature:r,method:d},this._methods[e.name]=a,this._methods[t]=d,this._methods[r]=d}else if((0,n.b8)(e)){const o=(0,n.Bv)(e),i=(0,n.T3)(o),r=this._createContractEvent(e,t);e.signature=i,o in this._events&&"bound"!==e.name||(this._events[o]=r),this._events[e.name]=r,this._events[i]=r}r=[...r,e]}this._events.allEvents=this._createContractEvent(s.bV,t),this._jsonInterface=[...r],this._errorsInterface=c}_getAbiParams(e,t){var o;try{return d.Wp.transformJsonDataToAbiFormat(null!==(o=e.inputs)&&void 0!==o?o:[],t)}catch(i){throw new r.SNI(`Invalid parameters for method ${e.name}: ${i.message}`)}}_createContractMethod(e,t,o=!1){const i=e[e.length-1];return(...e)=>{var r,s,a;let c;const h=null!==(s=o?null===(r=this._overloadedMethodAbis.get(i.name))||void 0===r?void 0:r.filter(e=>e.signature===i.signature):this._overloadedMethodAbis.get(i.name))&&void 0!==s?s:[];let u=h[0];const f=t,p=h.filter(t=>{var o;return(null!==(o=t.inputs)&&void 0!==o?o:[]).length===e.length});if(1===h.length||0===p.length)c=this._getAbiParams(u,e),d.Nc.validate(null!==(a=i.inputs)&&void 0!==a?a:[],c);else{const t=[],o=[];for(const i of p)try{c=this._getAbiParams(i,e),d.Nc.validate(i.inputs,c),o.push(i)}catch(v){t.push(v)}if(1===o.length?[u]=o:o.length>1&&([u]=o,console.warn(`Multiple methods found that is compatible with the given inputs.\n\tFound ${o.length} compatible methods: ${JSON.stringify(o.map(e=>`${e.methodNameWithInputs} (signature: ${e.signature})`))} \n\tThe first one will be used: ${u.methodNameWithInputs}`)),t.length===p.length)throw new d.qT(t)}const g={arguments:c,call:(e,t)=>P(this,void 0,void 0,function*(){return this._contractMethodCall(u,c,f,e,t)}),send:e=>this._contractMethodSend(u,c,f,e),populateTransaction:(t,o)=>{var r,s;let n=null!==o&&void 0!==o?o:this.options;n=Object.assign(Object.assign({},n),{input:void 0,from:null!==(s=null!==(r=null===n||void 0===n?void 0:n.from)&&void 0!==r?r:this.defaultAccount)&&void 0!==s?s:void 0});const a=m({abi:i,params:e,options:Object.assign(Object.assign({},t),{dataInputFill:this.config.contractDataInputFill}),contractOptions:n});return a.dataInputFill&&delete a.dataInputFill,a},estimateGas:(e,...t)=>P(this,[e,...t],void 0,function*(e,t=this.defaultReturnFormat){return this.contractMethodEstimateGas({abi:u,params:c,returnFormat:t,options:e})}),encodeABI:()=>l(u,c),decodeData:e=>(0,n.bQ)(u,e),createAccessList:(e,t)=>P(this,void 0,void 0,function*(){return this._contractMethodCreateAccessList(u,c,f,e,t)})};return u.stateMutability,g}}_contractMethodCall(e,t,o,i,a){return P(this,void 0,void 0,function*(){var c;const d=p({abi:e,params:t,options:Object.assign(Object.assign({},i),{dataInputFill:this.config.contractDataInputFill}),contractOptions:Object.assign(Object.assign({},this.options),{from:null!==(c=this.options.from)&&void 0!==c?c:this.config.defaultAccount})});try{const t=yield(0,s.T1)(this,d,a,this.defaultReturnFormat);return(0,n.dM)(e,t)}catch(h){throw h instanceof r.fQB&&(0,n.Zo)(o,h.cause),h}})}_contractMethodCreateAccessList(e,t,o,i,a){return P(this,void 0,void 0,function*(){var c;const d=b({abi:e,params:t,options:Object.assign(Object.assign({},i),{dataInputFill:this.config.contractDataInputFill}),contractOptions:Object.assign(Object.assign({},this.options),{from:null!==(c=this.options.from)&&void 0!==c?c:this.config.defaultAccount})});try{return(0,s.Xy)(this,d,a,this.defaultReturnFormat)}catch(h){throw h instanceof r.fQB&&(0,n.Zo)(o,h.cause),h}})}_contractMethodSend(e,t,o,i,a){var c,h;let l=null!==a&&void 0!==a?a:this.options;l=Object.assign(Object.assign({},l),{input:void 0,from:null!==(h=null!==(c=l.from)&&void 0!==c?c:this.defaultAccount)&&void 0!==h?h:void 0});const u=m({abi:e,params:t,options:Object.assign(Object.assign({},i),{dataInputFill:this.config.contractDataInputFill}),contractOptions:l}),f=(0,d.uy)(this.transactionMiddleware)?(0,s.vD)(this,u,this.defaultReturnFormat,{checkRevertBeforeSending:!1,contractAbi:this._jsonInterface}):(0,s.vD)(this,u,this.defaultReturnFormat,{checkRevertBeforeSending:!1,contractAbi:this._jsonInterface},this.transactionMiddleware);return f.on("error",e=>{e instanceof r.fQB&&(0,n.Zo)(o,e.cause)}),f}contractMethodEstimateGas(e){return P(this,arguments,void 0,function*({abi:e,params:t,returnFormat:o,options:i,contractOptions:r}){const n=g({abi:e,params:t,options:Object.assign(Object.assign({},i),{dataInputFill:this.config.contractDataInputFill}),contractOptions:null!==r&&void 0!==r?r:this.options});return(0,s.Qr)(this,n,a.zC.LATEST,null!==o&&void 0!==o?o:this.defaultReturnFormat)})}_createContractEvent(e,t=this.defaultReturnFormat){return(...o)=>{var i;const{topics:s,fromBlock:n}=h(this.options,e,o[0]),a=new u({address:this.options.address,topics:s,abi:e,jsonInterface:this._jsonInterface},{subscriptionManager:this.subscriptionManager,returnFormat:t});return(0,d.uy)(n)||this.getPastEvents(e.name,{fromBlock:n,topics:s},t).then(e=>{e&&e.forEach(e=>a.emit("data",e))}).catch(e=>{a.emit("error",new r.AAt("Failed to get past events.",e))}),null===(i=this.subscriptionManager)||void 0===i||i.addSubscription(a).catch(e=>{a.emit("error",new r.AAt("Failed to subscribe.",e))}),a}}subscribeToContextEvents(e){const t=this;this.context=e,t.syncWithContext&&e.on(i.AL.CONFIG_CHANGE,e=>{t.setConfig({[e.name]:e.newValue})})}}const x=S},85834:(e,t,o)=>{o.d(t,{y_:()=>Le,nx:()=>Ye,ZX:()=>ot,dF:()=>rt,Q9:()=>L,uX:()=>dt,Qu:()=>ht,_S:()=>ct});var i=o(20345),r=o(85334);i.K5;o(21089),o(55329),o(46027);var s,n=o(39788),a=o(14387),c=o(37033),d=o(74134);const h=null!==(s=c.bI)&&void 0!==s?s:d,l=BigInt("0xffffffffffffffff"),u=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),f=h.CURVE.n,m=f/BigInt(2);var p,g,v,b,y,k;(function(e){e[e["Mainnet"]=1]="Mainnet",e[e["Goerli"]=5]="Goerli",e[e["Sepolia"]=11155111]="Sepolia"})(p||(p={})),function(e){e["Chainstart"]="chainstart",e["Homestead"]="homestead",e["Dao"]="dao",e["TangerineWhistle"]="tangerineWhistle",e["SpuriousDragon"]="spuriousDragon",e["Byzantium"]="byzantium",e["Constantinople"]="constantinople",e["Petersburg"]="petersburg",e["Istanbul"]="istanbul",e["MuirGlacier"]="muirGlacier",e["Berlin"]="berlin",e["London"]="london",e["ArrowGlacier"]="arrowGlacier",e["GrayGlacier"]="grayGlacier",e["MergeForkIdTransition"]="mergeForkIdTransition",e["Merge"]="merge",e["Shanghai"]="shanghai",e["ShardingForkDev"]="shardingFork"}(g||(g={})),function(e){e["ProofOfStake"]="pos",e["ProofOfWork"]="pow",e["ProofOfAuthority"]="poa"}(v||(v={})),function(e){e["Ethash"]="ethash",e["Clique"]="clique",e["Casper"]="casper"}(b||(b={})),function(e){e["PolygonMainnet"]="polygon-mainnet",e["PolygonMumbai"]="polygon-mumbai",e["ArbitrumRinkebyTestnet"]="arbitrum-rinkeby-testnet",e["ArbitrumOne"]="arbitrum-one",e["xDaiChain"]="x-dai-chain",e["OptimisticKovan"]="optimistic-kovan",e["OptimisticEthereum"]="optimistic-ethereum"}(y||(y={})),function(e){e[e["Number"]=0]="Number",e[e["BigInt"]=1]="BigInt",e[e["Uint8Array"]=2]="Uint8Array",e[e["PrefixedHexString"]=3]="PrefixedHexString"}(k||(k={}));const I=e=>{if("string"!==typeof e)throw new Error("[stripHexPrefix] input must be type 'string', received "+typeof e);return(0,r.Xs)(e)?e.slice(2):e};function E(e){return e&&"0x0"!==e?(0,r.Xs)(e)?`0x${I(e).padStart(16,"0")}`:`0x${e.padStart(16,"0")}`:"0x0000000000000000"}const P=function(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Received an invalid integer type: ${e}`);return`0x${e.toString(16)}`};function w(e,t=!0){var o,i;const{name:s,config:n,difficulty:a,mixHash:c,gasLimit:d,coinbase:h,baseFeePerGas:l}=e;let{extraData:u,timestamp:f,nonce:m}=e;const p=Number(f),{chainId:v}=n;if(""===u&&(u="0x"),(0,r.Xs)(f)||(f=P(parseInt(f))),18!==m.length&&(m=E(m)),n.eip155Block!==n.eip158Block)throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");const b={name:s,chainId:v,networkId:v,genesis:{timestamp:f,gasLimit:parseInt(d),difficulty:parseInt(a),nonce:m,extraData:u,mixHash:c,coinbase:h,baseFeePerGas:l},hardfork:void 0,hardforks:[],bootstrapNodes:[],consensus:void 0!==n.clique?{type:"poa",algorithm:"clique",clique:{period:null!==(o=n.clique.period)&&void 0!==o?o:n.clique.blockperiodseconds,epoch:null!==(i=n.clique.epoch)&&void 0!==i?i:n.clique.epochlength}}:{type:"pow",algorithm:"ethash",ethash:{}}},y={[g.Homestead]:{name:"homesteadBlock"},[g.Dao]:{name:"daoForkBlock"},[g.TangerineWhistle]:{name:"eip150Block"},[g.SpuriousDragon]:{name:"eip155Block"},[g.Byzantium]:{name:"byzantiumBlock"},[g.Constantinople]:{name:"constantinopleBlock"},[g.Petersburg]:{name:"petersburgBlock"},[g.Istanbul]:{name:"istanbulBlock"},[g.MuirGlacier]:{name:"muirGlacierBlock"},[g.Berlin]:{name:"berlinBlock"},[g.London]:{name:"londonBlock"},[g.MergeForkIdTransition]:{name:"mergeForkBlock",postMerge:t},[g.Shanghai]:{name:"shanghaiTime",postMerge:!0,isTimestamp:!0},[g.ShardingForkDev]:{name:"shardingForkTime",postMerge:!0,isTimestamp:!0}},k=Object.keys(y).reduce((e,t)=>(e[y[t].name]=t,e),{}),I=Object.keys(n).filter(e=>void 0!==k[e]&&void 0!==n[e]&&null!==n[e]);if(b.hardforks=I.map(e=>({name:k[e],block:!0===y[k[e]].isTimestamp||"number"!==typeof n[e]?null:n[e],timestamp:!0===y[k[e]].isTimestamp&&"number"===typeof n[e]?n[e]:void 0})).filter(e=>null!==e.block||void 0!==e.timestamp),b.hardforks.sort((e,t)=>{var o,i;return(null!==(o=e.block)&&void 0!==o?o:1/0)-(null!==(i=t.block)&&void 0!==i?i:1/0)}),b.hardforks.sort((e,t)=>{var o,i;return(null!==(o=e.timestamp)&&void 0!==o?o:p)-(null!==(i=t.timestamp)&&void 0!==i?i:p)}),void 0!==n.terminalTotalDifficulty){const e={name:g.Merge,ttd:n.terminalTotalDifficulty,block:null},t=b.hardforks.findIndex(e=>{var t;return!0===(null===(t=y[e.name])||void 0===t?void 0:t.postMerge)});-1!==t?b.hardforks.splice(t,0,e):b.hardforks.push(e)}const w=b.hardforks.length>0?b.hardforks.slice(-1)[0]:void 0;return b.hardfork=null===w||void 0===w?void 0:w.name,b.hardforks.unshift({name:g.Chainstart,block:0}),b}function S(e,t,o){try{if(["config","difficulty","gasLimit","alloc"].some(t=>!(t in e)))throw new Error("Invalid format, expected geth genesis fields missing");return void 0!==t&&(e.name=t),w(e,o)}catch(i){throw new Error(`Error parsing parameters file: ${i.message}`)}}function x(e){let t=e;if("string"!==typeof t)throw new Error("[padToEven] value must be type 'string', received "+typeof t);return t.length%2&&(t=`0${t}`),t}const B=function(e){const t=P(e);return(0,a.aT)(`0x${x(t.slice(2))}`)},A=function(e){var t;if(null===e||void 0===e)return new Uint8Array;if(e instanceof Uint8Array)return e;if("Uint8Array"===(null===(t=null===e||void 0===e?void 0:e.constructor)||void 0===t?void 0:t.name))return Uint8Array.from(e);if(Array.isArray(e))return Uint8Array.from(e);if("string"===typeof e){if(!(0,r.Lo)(e))throw new Error(`Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${e}`);return(0,a.aT)(x(I(e)))}if("number"===typeof e)return A((0,a.cK)(e));if("bigint"===typeof e){if(e<BigInt(0))throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${e}`);let t=e.toString(16);return t.length%2&&(t=`0${t}`),A(`0x${t}`)}if(e.toArray)return Uint8Array.from(e.toArray());throw new Error("invalid type")};function O(e){const t=(0,a.My)(e);return"0x"===t?BigInt(0):BigInt(t)}function C(e){return A(`0x${e.toString(16)}`)}const T=function(e){return new Uint8Array(e).fill(0)},F=function(e,t,o){const i=T(t);return o?e.length<t?(i.set(e),i):e.subarray(0,t):e.length<t?(i.set(e,t-e.length),i):e.subarray(-t)};function _(e){if(!(0,a.mg)(e)){const t=`This method only supports Uint8Array but input was: ${e}`;throw new Error(t)}}const D=function(e,t){return _(e),F(e,t,!1)};function H(e){let t=e[0];while(e.length>0&&"0"===t.toString())e=e.slice(1),t=e[0];return e}const M=function(e){return _(e),H(e)},L=e=>`0x${e.toString(16)}`;function R(e){return M(C(e))}function G(e,t){return e===BigInt(0)||e===BigInt(1)?e:void 0===t?e-BigInt(27):e-(t*BigInt(2)+BigInt(35))}function N(e){return e===BigInt(0)||e===BigInt(1)}const j=function(e,t,o,i,r){const s=G(t,r);if(!N(s))throw new Error("Invalid signature v value");const n=new h.Signature(O(o),O(i)).addRecoveryBit(Number(s)).recoverPublicKey(e).toRawBytes(!1);return n.slice(1)};function z(e,t){if(null===e)return null;if(void 0===e)return;if("string"===typeof e&&!(0,r.Lo)(e))throw new Error(`A string must be provided with a 0x-prefix, given: ${e}`);if("number"===typeof e&&!Number.isSafeInteger(e))throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");const o=A(e);switch(t){case k.Uint8Array:return o;case k.BigInt:return O(o);case k.Number:{const e=O(o);if(e>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");return Number(e)}case k.PrefixedHexString:return(0,a.My)(o);default:throw new Error("unknown outputType")}}var $=o(90433),U=o(66289),q=o(52566);const V={name:"goerli",chainId:5,networkId:5,defaultHardfork:"merge",consensus:{type:"poa",algorithm:"clique",clique:{period:15,epoch:3e4}},comment:"Cross-client PoA test network",url:"https://github.com/goerli/testnet",genesis:{timestamp:"0x5c51a607",gasLimit:10485760,difficulty:1,nonce:"0x0000000000000000",extraData:"0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},hardforks:[{name:"chainstart",block:0,forkHash:"0xa3f5ab08"},{name:"homestead",block:0,forkHash:"0xa3f5ab08"},{name:"tangerineWhistle",block:0,forkHash:"0xa3f5ab08"},{name:"spuriousDragon",block:0,forkHash:"0xa3f5ab08"},{name:"byzantium",block:0,forkHash:"0xa3f5ab08"},{name:"constantinople",block:0,forkHash:"0xa3f5ab08"},{name:"petersburg",block:0,forkHash:"0xa3f5ab08"},{name:"istanbul",block:1561651,forkHash:"0xc25efa5c"},{name:"berlin",block:4460644,forkHash:"0x757a1c47"},{name:"london",block:5062605,forkHash:"0xb8c6299d"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",name:"merge",ttd:"10790000",block:7382819,forkHash:"0xb8c6299d"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],bootstrapNodes:[],dnsNetworks:["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"]},X={name:"mainnet",chainId:1,networkId:1,defaultHardfork:"merge",consensus:{type:"pow",algorithm:"ethash",ethash:{}},comment:"The Ethereum main chain",url:"https://ethstats.net/",genesis:{gasLimit:5e3,difficulty:17179869184,nonce:"0x0000000000000042",extraData:"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"},hardforks:[{name:"chainstart",block:0,forkHash:"0xfc64ec04"},{name:"homestead",block:115e4,forkHash:"0x97c2c34c"},{name:"dao",block:192e4,forkHash:"0x91d1f948"},{name:"tangerineWhistle",block:2463e3,forkHash:"0x7a64da13"},{name:"spuriousDragon",block:2675e3,forkHash:"0x3edd5b10"},{name:"byzantium",block:437e4,forkHash:"0xa00bc324"},{name:"constantinople",block:728e4,forkHash:"0x668db0af"},{name:"petersburg",block:728e4,forkHash:"0x668db0af"},{name:"istanbul",block:9069e3,forkHash:"0x879d6e30"},{name:"muirGlacier",block:92e5,forkHash:"0xe029e991"},{name:"berlin",block:12244e3,forkHash:"0x0eb440f6"},{name:"london",block:12965e3,forkHash:"0xb715077d"},{name:"arrowGlacier",block:13773e3,forkHash:"0x20c327fc"},{name:"grayGlacier",block:1505e4,forkHash:"0xf0afd0e3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",name:"merge",ttd:"58750000000000000000000",block:15537394,forkHash:"0xf0afd0e3"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],bootstrapNodes:[],dnsNetworks:["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"]},K={name:"sepolia",chainId:11155111,networkId:11155111,defaultHardfork:"merge",consensus:{type:"pow",algorithm:"ethash",ethash:{}},comment:"PoW test network to replace Ropsten",url:"https://github.com/ethereum/go-ethereum/pull/23730",genesis:{timestamp:"0x6159af19",gasLimit:3e7,difficulty:131072,nonce:"0x0000000000000000",extraData:"0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"},hardforks:[{name:"chainstart",block:0,forkHash:"0xfe3366e7"},{name:"homestead",block:0,forkHash:"0xfe3366e7"},{name:"tangerineWhistle",block:0,forkHash:"0xfe3366e7"},{name:"spuriousDragon",block:0,forkHash:"0xfe3366e7"},{name:"byzantium",block:0,forkHash:"0xfe3366e7"},{name:"constantinople",block:0,forkHash:"0xfe3366e7"},{name:"petersburg",block:0,forkHash:"0xfe3366e7"},{name:"istanbul",block:0,forkHash:"0xfe3366e7"},{name:"muirGlacier",block:0,forkHash:"0xfe3366e7"},{name:"berlin",block:0,forkHash:"0xfe3366e7"},{name:"london",block:0,forkHash:"0xfe3366e7"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",name:"merge",ttd:"17000000000000000",block:1450409,forkHash:"0xfe3366e7"},{name:"mergeForkIdTransition",block:1735371,forkHash:"0xb96cbd13"},{name:"shanghai",block:null,timestamp:"1677557088",forkHash:"0xf7f9bc08"}],bootstrapNodes:[],dnsNetworks:["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"]},W={name:"EIP-1153",number:1153,comment:"Transient Storage",url:"https://eips.ethereum.org/EIPS/eip-1153",status:"Review",minimumHardfork:"chainstart",requiredEIPs:[],gasConfig:{},gasPrices:{tstore:{v:100,d:"Base fee of the TSTORE opcode"},tload:{v:100,d:"Base fee of the TLOAD opcode"}},vm:{},pow:{}},Y={name:"EIP-1559",number:1559,comment:"Fee market change for ETH 1.0 chain",url:"https://eips.ethereum.org/EIPS/eip-1559",status:"Final",minimumHardfork:"berlin",requiredEIPs:[2930],gasConfig:{baseFeeMaxChangeDenominator:{v:8,d:"Maximum base fee change denominator"},elasticityMultiplier:{v:2,d:"Maximum block gas target elasticity"},initialBaseFee:{v:1e9,d:"Initial base fee on first EIP1559 block"}},gasPrices:{},vm:{},pow:{}},J={name:"EIP-2315",number:2315,comment:"Simple subroutines for the EVM",url:"https://eips.ethereum.org/EIPS/eip-2315",status:"Draft",minimumHardfork:"istanbul",gasConfig:{},gasPrices:{beginsub:{v:2,d:"Base fee of the BEGINSUB opcode"},returnsub:{v:5,d:"Base fee of the RETURNSUB opcode"},jumpsub:{v:10,d:"Base fee of the JUMPSUB opcode"}},vm:{},pow:{}},Q={name:"EIP-2537",number:2537,comment:"BLS12-381 precompiles",url:"https://eips.ethereum.org/EIPS/eip-2537",status:"Draft",minimumHardfork:"chainstart",gasConfig:{},gasPrices:{Bls12381G1AddGas:{v:600,d:"Gas cost of a single BLS12-381 G1 addition precompile-call"},Bls12381G1MulGas:{v:12e3,d:"Gas cost of a single BLS12-381 G1 multiplication precompile-call"},Bls12381G2AddGas:{v:4500,d:"Gas cost of a single BLS12-381 G2 addition precompile-call"},Bls12381G2MulGas:{v:55e3,d:"Gas cost of a single BLS12-381 G2 multiplication precompile-call"},Bls12381PairingBaseGas:{v:115e3,d:"Base gas cost of BLS12-381 pairing check"},Bls12381PairingPerPairGas:{v:23e3,d:"Per-pair gas cost of BLS12-381 pairing check"},Bls12381MapG1Gas:{v:5500,d:"Gas cost of BLS12-381 map field element to G1"},Bls12381MapG2Gas:{v:11e4,d:"Gas cost of BLS12-381 map field element to G2"},Bls12381MultiExpGasDiscount:{v:[[1,1200],[2,888],[3,764],[4,641],[5,594],[6,547],[7,500],[8,453],[9,438],[10,423],[11,408],[12,394],[13,379],[14,364],[15,349],[16,334],[17,330],[18,326],[19,322],[20,318],[21,314],[22,310],[23,306],[24,302],[25,298],[26,294],[27,289],[28,285],[29,281],[30,277],[31,273],[32,269],[33,268],[34,266],[35,265],[36,263],[37,262],[38,260],[39,259],[40,257],[41,256],[42,254],[43,253],[44,251],[45,250],[46,248],[47,247],[48,245],[49,244],[50,242],[51,241],[52,239],[53,238],[54,236],[55,235],[56,233],[57,232],[58,231],[59,229],[60,228],[61,226],[62,225],[63,223],[64,222],[65,221],[66,220],[67,219],[68,219],[69,218],[70,217],[71,216],[72,216],[73,215],[74,214],[75,213],[76,213],[77,212],[78,211],[79,211],[80,210],[81,209],[82,208],[83,208],[84,207],[85,206],[86,205],[87,205],[88,204],[89,203],[90,202],[91,202],[92,201],[93,200],[94,199],[95,199],[96,198],[97,197],[98,196],[99,196],[100,195],[101,194],[102,193],[103,193],[104,192],[105,191],[106,191],[107,190],[108,189],[109,188],[110,188],[111,187],[112,186],[113,185],[114,185],[115,184],[116,183],[117,182],[118,182],[119,181],[120,180],[121,179],[122,179],[123,178],[124,177],[125,176],[126,176],[127,175],[128,174]],d:"Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"}},vm:{},pow:{}},Z={name:"EIP-2565",number:2565,comment:"ModExp gas cost",url:"https://eips.ethereum.org/EIPS/eip-2565",status:"Final",minimumHardfork:"byzantium",gasConfig:{},gasPrices:{modexpGquaddivisor:{v:3,d:"Gquaddivisor from modexp precompile for gas calculation"}},vm:{},pow:{}},ee={name:"EIP-2718",comment:"Typed Transaction Envelope",url:"https://eips.ethereum.org/EIPS/eip-2718",status:"Final",minimumHardfork:"chainstart",gasConfig:{},gasPrices:{},vm:{},pow:{}},te={name:"EIP-2929",comment:"Gas cost increases for state access opcodes",url:"https://eips.ethereum.org/EIPS/eip-2929",status:"Final",minimumHardfork:"chainstart",gasConfig:{},gasPrices:{coldsload:{v:2100,d:"Gas cost of the first read of storage from a given location (per transaction)"},coldaccountaccess:{v:2600,d:"Gas cost of the first read of a given address (per transaction)"},warmstorageread:{v:100,d:"Gas cost of reading storage locations which have already loaded 'cold'"},sstoreCleanGasEIP2200:{v:2900,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreNoopGasEIP2200:{v:100,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:100,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitRefundEIP2200:{v:19900,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanRefundEIP2200:{v:4900,d:"Once per SSTORE operation for resetting to the original non-zero value"},call:{v:0,d:"Base fee of the CALL opcode"},callcode:{v:0,d:"Base fee of the CALLCODE opcode"},delegatecall:{v:0,d:"Base fee of the DELEGATECALL opcode"},staticcall:{v:0,d:"Base fee of the STATICCALL opcode"},balance:{v:0,d:"Base fee of the BALANCE opcode"},extcodesize:{v:0,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:0,d:"Base fee of the EXTCODECOPY opcode"},extcodehash:{v:0,d:"Base fee of the EXTCODEHASH opcode"},sload:{v:0,d:"Base fee of the SLOAD opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"}},vm:{},pow:{}},oe={name:"EIP-2930",comment:"Optional access lists",url:"https://eips.ethereum.org/EIPS/eip-2930",status:"Final",minimumHardfork:"istanbul",requiredEIPs:[2718,2929],gasConfig:{},gasPrices:{accessListStorageKeyCost:{v:1900,d:"Gas cost per storage key in an Access List transaction"},accessListAddressCost:{v:2400,d:"Gas cost per storage key in an Access List transaction"}},vm:{},pow:{}},ie={name:"EIP-3198",number:3198,comment:"BASEFEE opcode",url:"https://eips.ethereum.org/EIPS/eip-3198",status:"Final",minimumHardfork:"london",gasConfig:{},gasPrices:{basefee:{v:2,d:"Gas cost of the BASEFEE opcode"}},vm:{},pow:{}},re={name:"EIP-3529",comment:"Reduction in refunds",url:"https://eips.ethereum.org/EIPS/eip-3529",status:"Final",minimumHardfork:"berlin",requiredEIPs:[2929],gasConfig:{maxRefundQuotient:{v:5,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},gasPrices:{selfdestructRefund:{v:0,d:"Refunded following a selfdestruct operation"},sstoreClearRefundEIP2200:{v:4800,d:"Once per SSTORE operation for clearing an originally existing storage slot"}},vm:{},pow:{}},se={name:"EIP-3540",number:3540,comment:"EVM Object Format (EOF) v1",url:"https://eips.ethereum.org/EIPS/eip-3540",status:"Review",minimumHardfork:"london",requiredEIPs:[3541],gasConfig:{},gasPrices:{},vm:{},pow:{}},ne={name:"EIP-3541",comment:"Reject new contracts starting with the 0xEF byte",url:"https://eips.ethereum.org/EIPS/eip-3541",status:"Final",minimumHardfork:"berlin",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{}},ae={name:"EIP-3554",comment:"Reduction in refunds",url:"Difficulty Bomb Delay to December 1st 2021",status:"Final",minimumHardfork:"muirGlacier",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{difficultyBombDelay:{v:95e5,d:"the amount of blocks to delay the difficulty bomb with"}}},ce={name:"EIP-3607",number:3607,comment:"Reject transactions from senders with deployed code",url:"https://eips.ethereum.org/EIPS/eip-3607",status:"Final",minimumHardfork:"chainstart",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{}},de={name:"EIP-3651",number:3198,comment:"Warm COINBASE",url:"https://eips.ethereum.org/EIPS/eip-3651",status:"Review",minimumHardfork:"london",requiredEIPs:[2929],gasConfig:{},gasPrices:{},vm:{},pow:{}},he={name:"EIP-3670",number:3670,comment:"EOF - Code Validation",url:"https://eips.ethereum.org/EIPS/eip-3670",status:"Review",minimumHardfork:"london",requiredEIPs:[3540],gasConfig:{},gasPrices:{},vm:{},pow:{}},le={name:"EIP-3675",number:3675,comment:"Upgrade consensus to Proof-of-Stake",url:"https://eips.ethereum.org/EIPS/eip-3675",status:"Final",minimumHardfork:"london",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{}},ue={name:"EIP-3855",number:3855,comment:"PUSH0 instruction",url:"https://eips.ethereum.org/EIPS/eip-3855",status:"Review",minimumHardfork:"chainstart",requiredEIPs:[],gasConfig:{},gasPrices:{push0:{v:2,d:"Base fee of the PUSH0 opcode"}},vm:{},pow:{}},fe={name:"EIP-3860",number:3860,comment:"Limit and meter initcode",url:"https://eips.ethereum.org/EIPS/eip-3860",status:"Review",minimumHardfork:"spuriousDragon",requiredEIPs:[],gasConfig:{},gasPrices:{initCodeWordCost:{v:2,d:"Gas to pay for each word (32 bytes) of initcode when creating a contract"}},vm:{maxInitCodeSize:{v:49152,d:"Maximum length of initialization code when creating a contract"}},pow:{}},me={name:"EIP-4345",number:4345,comment:"Difficulty Bomb Delay to June 2022",url:"https://eips.ethereum.org/EIPS/eip-4345",status:"Final",minimumHardfork:"london",gasConfig:{},gasPrices:{},vm:{},pow:{difficultyBombDelay:{v:107e5,d:"the amount of blocks to delay the difficulty bomb with"}}},pe={name:"EIP-4399",number:4399,comment:"Supplant DIFFICULTY opcode with PREVRANDAO",url:"https://eips.ethereum.org/EIPS/eip-4399",status:"Review",minimumHardfork:"london",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{}},ge={name:"EIP-5133",number:5133,comment:"Delaying Difficulty Bomb to mid-September 2022",url:"https://eips.ethereum.org/EIPS/eip-5133",status:"Draft",minimumHardfork:"grayGlacier",gasConfig:{},gasPrices:{},vm:{},pow:{difficultyBombDelay:{v:114e5,d:"the amount of blocks to delay the difficulty bomb with"}}},ve={1153:W,1559:Y,2315:J,2537:Q,2565:Z,2718:ee,2929:te,2930:oe,3198:ie,3529:re,3540:se,3541:ne,3554:ae,3607:ce,3651:de,3670:he,3675:le,3855:ue,3860:fe,4345:me,4399:pe,5133:ge},be={name:"chainstart",comment:"Start of the Ethereum main chain",url:"",status:"",gasConfig:{minGasLimit:{v:5e3,d:"Minimum the gas limit may ever be"},gasLimitBoundDivisor:{v:1024,d:"The bound divisor of the gas limit, used in update calculations"},maxRefundQuotient:{v:2,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},gasPrices:{base:{v:2,d:"Gas base cost, used e.g. for ChainID opcode (Istanbul)"},tierStep:{v:[0,2,3,5,8,10,20],d:"Once per operation, for a selection of them"},exp:{v:10,d:"Base fee of the EXP opcode"},expByte:{v:10,d:"Times ceil(log256(exponent)) for the EXP instruction"},sha3:{v:30,d:"Base fee of the SHA3 opcode"},sha3Word:{v:6,d:"Once per word of the SHA3 operation's data"},sload:{v:50,d:"Base fee of the SLOAD opcode"},sstoreSet:{v:2e4,d:"Once per SSTORE operation if the zeroness changes from zero"},sstoreReset:{v:5e3,d:"Once per SSTORE operation if the zeroness does not change from zero"},sstoreRefund:{v:15e3,d:"Once per SSTORE operation if the zeroness changes to zero"},jumpdest:{v:1,d:"Base fee of the JUMPDEST opcode"},log:{v:375,d:"Base fee of the LOG opcode"},logData:{v:8,d:"Per byte in a LOG* operation's data"},logTopic:{v:375,d:"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"},create:{v:32e3,d:"Base fee of the CREATE opcode"},call:{v:40,d:"Base fee of the CALL opcode"},callStipend:{v:2300,d:"Free gas given at beginning of call"},callValueTransfer:{v:9e3,d:"Paid for CALL when the value transfor is non-zero"},callNewAccount:{v:25e3,d:"Paid for CALL when the destination address didn't exist prior"},selfdestructRefund:{v:24e3,d:"Refunded following a selfdestruct operation"},memory:{v:3,d:"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"},quadCoeffDiv:{v:512,d:"Divisor for the quadratic particle of the memory cost equation"},createData:{v:200,d:""},tx:{v:21e3,d:"Per transaction. NOTE: Not payable on data of calls between transactions"},txCreation:{v:32e3,d:"The cost of creating a contract via tx"},txDataZero:{v:4,d:"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"},txDataNonZero:{v:68,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},copy:{v:3,d:"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"},ecRecover:{v:3e3,d:""},sha256:{v:60,d:""},sha256Word:{v:12,d:""},ripemd160:{v:600,d:""},ripemd160Word:{v:120,d:""},identity:{v:15,d:""},identityWord:{v:3,d:""},stop:{v:0,d:"Base fee of the STOP opcode"},add:{v:3,d:"Base fee of the ADD opcode"},mul:{v:5,d:"Base fee of the MUL opcode"},sub:{v:3,d:"Base fee of the SUB opcode"},div:{v:5,d:"Base fee of the DIV opcode"},sdiv:{v:5,d:"Base fee of the SDIV opcode"},mod:{v:5,d:"Base fee of the MOD opcode"},smod:{v:5,d:"Base fee of the SMOD opcode"},addmod:{v:8,d:"Base fee of the ADDMOD opcode"},mulmod:{v:8,d:"Base fee of the MULMOD opcode"},signextend:{v:5,d:"Base fee of the SIGNEXTEND opcode"},lt:{v:3,d:"Base fee of the LT opcode"},gt:{v:3,d:"Base fee of the GT opcode"},slt:{v:3,d:"Base fee of the SLT opcode"},sgt:{v:3,d:"Base fee of the SGT opcode"},eq:{v:3,d:"Base fee of the EQ opcode"},iszero:{v:3,d:"Base fee of the ISZERO opcode"},and:{v:3,d:"Base fee of the AND opcode"},or:{v:3,d:"Base fee of the OR opcode"},xor:{v:3,d:"Base fee of the XOR opcode"},not:{v:3,d:"Base fee of the NOT opcode"},byte:{v:3,d:"Base fee of the BYTE opcode"},address:{v:2,d:"Base fee of the ADDRESS opcode"},balance:{v:20,d:"Base fee of the BALANCE opcode"},origin:{v:2,d:"Base fee of the ORIGIN opcode"},caller:{v:2,d:"Base fee of the CALLER opcode"},callvalue:{v:2,d:"Base fee of the CALLVALUE opcode"},calldataload:{v:3,d:"Base fee of the CALLDATALOAD opcode"},calldatasize:{v:2,d:"Base fee of the CALLDATASIZE opcode"},calldatacopy:{v:3,d:"Base fee of the CALLDATACOPY opcode"},codesize:{v:2,d:"Base fee of the CODESIZE opcode"},codecopy:{v:3,d:"Base fee of the CODECOPY opcode"},gasprice:{v:2,d:"Base fee of the GASPRICE opcode"},extcodesize:{v:20,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:20,d:"Base fee of the EXTCODECOPY opcode"},blockhash:{v:20,d:"Base fee of the BLOCKHASH opcode"},coinbase:{v:2,d:"Base fee of the COINBASE opcode"},timestamp:{v:2,d:"Base fee of the TIMESTAMP opcode"},number:{v:2,d:"Base fee of the NUMBER opcode"},difficulty:{v:2,d:"Base fee of the DIFFICULTY opcode"},gaslimit:{v:2,d:"Base fee of the GASLIMIT opcode"},pop:{v:2,d:"Base fee of the POP opcode"},mload:{v:3,d:"Base fee of the MLOAD opcode"},mstore:{v:3,d:"Base fee of the MSTORE opcode"},mstore8:{v:3,d:"Base fee of the MSTORE8 opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"},jump:{v:8,d:"Base fee of the JUMP opcode"},jumpi:{v:10,d:"Base fee of the JUMPI opcode"},pc:{v:2,d:"Base fee of the PC opcode"},msize:{v:2,d:"Base fee of the MSIZE opcode"},gas:{v:2,d:"Base fee of the GAS opcode"},push:{v:3,d:"Base fee of the PUSH opcode"},dup:{v:3,d:"Base fee of the DUP opcode"},swap:{v:3,d:"Base fee of the SWAP opcode"},callcode:{v:40,d:"Base fee of the CALLCODE opcode"},return:{v:0,d:"Base fee of the RETURN opcode"},invalid:{v:0,d:"Base fee of the INVALID opcode"},selfdestruct:{v:0,d:"Base fee of the SELFDESTRUCT opcode"}},vm:{stackLimit:{v:1024,d:"Maximum size of VM stack allowed"},callCreateDepth:{v:1024,d:"Maximum depth of call/create stack"},maxExtraDataSize:{v:32,d:"Maximum size extra data may be after Genesis"}},pow:{minimumDifficulty:{v:131072,d:"The minimum that the difficulty may ever be"},difficultyBoundDivisor:{v:2048,d:"The bound divisor of the difficulty, used in the update calculations"},durationLimit:{v:13,d:"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"},epochDuration:{v:3e4,d:"Duration between proof-of-work epochs"},timebombPeriod:{v:1e5,d:"Exponential difficulty timebomb period"},minerReward:{v:"5000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:0,d:"the amount of blocks to delay the difficulty bomb with"}}},ye={name:"dao",comment:"DAO rescue hardfork",url:"https://eips.ethereum.org/EIPS/eip-779",status:"Final",gasConfig:{},gasPrices:{},vm:{},pow:{}},ke={name:"homestead",comment:"Homestead hardfork with protocol and network changes",url:"https://eips.ethereum.org/EIPS/eip-606",status:"Final",gasConfig:{},gasPrices:{delegatecall:{v:40,d:"Base fee of the DELEGATECALL opcode"}},vm:{},pow:{}},Ie={name:"tangerineWhistle",comment:"Hardfork with gas cost changes for IO-heavy operations",url:"https://eips.ethereum.org/EIPS/eip-608",status:"Final",gasConfig:{},gasPrices:{sload:{v:200,d:"Once per SLOAD operation"},call:{v:700,d:"Once per CALL operation & message call transaction"},extcodesize:{v:700,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:700,d:"Base fee of the EXTCODECOPY opcode"},balance:{v:400,d:"Base fee of the BALANCE opcode"},delegatecall:{v:700,d:"Base fee of the DELEGATECALL opcode"},callcode:{v:700,d:"Base fee of the CALLCODE opcode"},selfdestruct:{v:5e3,d:"Base fee of the SELFDESTRUCT opcode"}},vm:{},pow:{}},Ee={name:"spuriousDragon",comment:"HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",url:"https://eips.ethereum.org/EIPS/eip-607",status:"Final",gasConfig:{},gasPrices:{expByte:{v:50,d:"Times ceil(log256(exponent)) for the EXP instruction"}},vm:{maxCodeSize:{v:24576,d:"Maximum length of contract code"}},pow:{}},Pe={name:"byzantium",comment:"Hardfork with new precompiles, instructions and other protocol changes",url:"https://eips.ethereum.org/EIPS/eip-609",status:"Final",gasConfig:{},gasPrices:{modexpGquaddivisor:{v:20,d:"Gquaddivisor from modexp precompile for gas calculation"},ecAdd:{v:500,d:"Gas costs for curve addition precompile"},ecMul:{v:4e4,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:1e5,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:8e4,d:"Gas costs regarding curve pairing precompile input length"},revert:{v:0,d:"Base fee of the REVERT opcode"},staticcall:{v:700,d:"Base fee of the STATICCALL opcode"},returndatasize:{v:2,d:"Base fee of the RETURNDATASIZE opcode"},returndatacopy:{v:3,d:"Base fee of the RETURNDATACOPY opcode"}},vm:{},pow:{minerReward:{v:"3000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:3e6,d:"the amount of blocks to delay the difficulty bomb with"}}},we={name:"constantinople",comment:"Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",url:"https://eips.ethereum.org/EIPS/eip-1013",status:"Final",gasConfig:{},gasPrices:{netSstoreNoopGas:{v:200,d:"Once per SSTORE operation if the value doesn't change"},netSstoreInitGas:{v:2e4,d:"Once per SSTORE operation from clean zero"},netSstoreCleanGas:{v:5e3,d:"Once per SSTORE operation from clean non-zero"},netSstoreDirtyGas:{v:200,d:"Once per SSTORE operation from dirty"},netSstoreClearRefund:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},netSstoreResetRefund:{v:4800,d:"Once per SSTORE operation for resetting to the original non-zero value"},netSstoreResetClearRefund:{v:19800,d:"Once per SSTORE operation for resetting to the original zero value"},shl:{v:3,d:"Base fee of the SHL opcode"},shr:{v:3,d:"Base fee of the SHR opcode"},sar:{v:3,d:"Base fee of the SAR opcode"},extcodehash:{v:400,d:"Base fee of the EXTCODEHASH opcode"},create2:{v:32e3,d:"Base fee of the CREATE2 opcode"}},vm:{},pow:{minerReward:{v:"2000000000000000000",d:"The amount a miner gets rewarded for mining a block"},difficultyBombDelay:{v:5e6,d:"the amount of blocks to delay the difficulty bomb with"}}},Se={name:"petersburg",comment:"Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",url:"https://eips.ethereum.org/EIPS/eip-1716",status:"Final",gasConfig:{},gasPrices:{netSstoreNoopGas:{v:null,d:"Removed along EIP-1283"},netSstoreInitGas:{v:null,d:"Removed along EIP-1283"},netSstoreCleanGas:{v:null,d:"Removed along EIP-1283"},netSstoreDirtyGas:{v:null,d:"Removed along EIP-1283"},netSstoreClearRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetClearRefund:{v:null,d:"Removed along EIP-1283"}},vm:{},pow:{}},xe={name:"istanbul",comment:"HF targeted for December 2019 following the Constantinople/Petersburg HF",url:"https://eips.ethereum.org/EIPS/eip-1679",status:"Final",gasConfig:{},gasPrices:{blake2Round:{v:1,d:"Gas cost per round for the Blake2 F precompile"},ecAdd:{v:150,d:"Gas costs for curve addition precompile"},ecMul:{v:6e3,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:45e3,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:34e3,d:"Gas costs regarding curve pairing precompile input length"},txDataNonZero:{v:16,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},sstoreSentryGasEIP2200:{v:2300,d:"Minimum gas required to be present for an SSTORE call, not consumed"},sstoreNoopGasEIP2200:{v:800,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:800,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitGasEIP2200:{v:2e4,d:"Once per SSTORE operation from clean zero to non-zero"},sstoreInitRefundEIP2200:{v:19200,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanGasEIP2200:{v:5e3,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreCleanRefundEIP2200:{v:4200,d:"Once per SSTORE operation for resetting to the original non-zero value"},sstoreClearRefundEIP2200:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},balance:{v:700,d:"Base fee of the BALANCE opcode"},extcodehash:{v:700,d:"Base fee of the EXTCODEHASH opcode"},chainid:{v:2,d:"Base fee of the CHAINID opcode"},selfbalance:{v:5,d:"Base fee of the SELFBALANCE opcode"},sload:{v:800,d:"Base fee of the SLOAD opcode"}},vm:{},pow:{}},Be={name:"muirGlacier",comment:"HF to delay the difficulty bomb",url:"https://eips.ethereum.org/EIPS/eip-2384",status:"Final",gasConfig:{},gasPrices:{},vm:{},pow:{difficultyBombDelay:{v:9e6,d:"the amount of blocks to delay the difficulty bomb with"}}},Ae={name:"berlin",comment:"HF targeted for July 2020 following the Muir Glacier HF",url:"https://eips.ethereum.org/EIPS/eip-2070",status:"Final",eips:[2565,2929,2718,2930]},Oe={name:"london",comment:"HF targeted for July 2021 following the Berlin fork",url:"https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",status:"Final",eips:[1559,3198,3529,3541]},Ce={name:"shanghai",comment:"Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",url:"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",status:"Final",eips:[3651,3855,3860,4895]},Te={name:"arrowGlacier",comment:"HF to delay the difficulty bomb",url:"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",status:"Final",eips:[4345],gasConfig:{},gasPrices:{},vm:{},pow:{}},Fe={name:"grayGlacier",comment:"Delaying the difficulty bomb to Mid September 2022",url:"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",status:"Draft",eips:[5133],gasConfig:{},gasPrices:{},vm:{},pow:{}},_e={name:"mergeForkIdTransition",comment:"Pre-merge hardfork to fork off non-upgraded clients",url:"https://eips.ethereum.org/EIPS/eip-3675",status:"Draft",eips:[]},De={name:"merge",comment:"Hardfork to upgrade the consensus mechanism to Proof-of-Stake",url:"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",status:"Final",consensus:{type:"pos",algorithm:"casper",casper:{}},eips:[3675,4399]},He={chainstart:be,homestead:ke,dao:ye,tangerineWhistle:Ie,spuriousDragon:Ee,byzantium:Pe,constantinople:we,petersburg:Se,istanbul:xe,muirGlacier:Be,berlin:Ae,london:Oe,shanghai:Ce,arrowGlacier:Te,grayGlacier:Fe,mergeForkIdTransition:_e,merge:De},{buf:Me}=q;class Le extends a.bk{static custom(e,t={}){var o;const i=null!==(o=t.baseChain)&&void 0!==o?o:"mainnet",r=Object.assign({},Le._getChainParams(i));if(r.name="custom-chain","string"!==typeof e)return new Le(Object.assign({chain:Object.assign(Object.assign({},r),e)},t));if(e===y.PolygonMainnet)return Le.custom({name:y.PolygonMainnet,chainId:137,networkId:137},t);if(e===y.PolygonMumbai)return Le.custom({name:y.PolygonMumbai,chainId:80001,networkId:80001},t);if(e===y.ArbitrumRinkebyTestnet)return Le.custom({name:y.ArbitrumRinkebyTestnet,chainId:421611,networkId:421611},t);if(e===y.ArbitrumOne)return Le.custom({name:y.ArbitrumOne,chainId:42161,networkId:42161},t);if(e===y.xDaiChain)return Le.custom({name:y.xDaiChain,chainId:100,networkId:100},t);if(e===y.OptimisticKovan)return Le.custom({name:y.OptimisticKovan,chainId:69,networkId:69},Object.assign({hardfork:g.Berlin},t));if(e===y.OptimisticEthereum)return Le.custom({name:y.OptimisticEthereum,chainId:10,networkId:10},Object.assign({hardfork:g.Berlin},t));throw new Error(`Custom chain ${e} not supported`)}static fromGethGenesis(e,{chain:t,eips:o,genesisHash:i,hardfork:r,mergeForkIdPostMerge:s}){var n;const a=S(e,t,s),c=new Le({chain:null!==(n=a.name)&&void 0!==n?n:"custom",customChains:[a],eips:o,hardfork:null!==r&&void 0!==r?r:a.hardfork});return void 0!==i&&c.setForkHashes(i),c}static isSupportedChainId(e){const t=this._getInitializedChains();return Boolean(t.names[e.toString()])}static _getChainParams(e,t){let o=e;const i=this._getInitializedChains(t);if("number"===typeof o||"bigint"===typeof o){if(o=o.toString(),i.names[o]){const e=i.names[o];return i[e]}throw new Error(`Chain with ID ${o} not supported`)}if(void 0!==i[o])return i[o];throw new Error(`Chain with name ${o} not supported`)}constructor(e){var t,o;super(),this._eips=[],this._customChains=null!==(t=e.customChains)&&void 0!==t?t:[],this._chainParams=this.setChain(e.chain),this.DEFAULT_HARDFORK=null!==(o=this._chainParams.defaultHardfork)&&void 0!==o?o:g.Merge,this.HARDFORK_CHANGES=this.hardforks().map(e=>[e.name,He[e.name]]),this._hardfork=this.DEFAULT_HARDFORK,void 0!==e.hardfork&&this.setHardfork(e.hardfork),e.eips&&this.setEIPs(e.eips)}setChain(e){if("number"===typeof e||"bigint"===typeof e||"string"===typeof e)this._chainParams=Le._getChainParams(e,this._customChains);else{if("object"!==typeof e)throw new Error("Wrong input format");{if(this._customChains.length>0)throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");const t=["networkId","genesis","hardforks","bootstrapNodes"];for(const o of t)if(!(o in e))throw new Error(`Missing required chain parameter: ${o}`);this._chainParams=e}}for(const t of this.hardforks())if(void 0===t.block)throw new Error("Hardfork cannot have undefined block number");return this._chainParams}setHardfork(e){let t=!1;for(const o of this.HARDFORK_CHANGES)o[0]===e&&(this._hardfork!==e&&(this._hardfork=e,this.emit("hardforkChanged",e)),t=!0);if(!t)throw new Error(`Hardfork with name ${e} not supported`)}getHardforkByBlockNumber(e,t,o){const i=z(e,k.BigInt),r=z(t,k.BigInt),s=z(o,k.Number),n=this.hardforks().filter(e=>null!==e.block||null!==e.ttd&&void 0!==e.ttd||void 0!==e.timestamp),a=n.findIndex(e=>null!==e.ttd&&void 0!==e.ttd),c=n.slice(a+1).findIndex(e=>null!==e.ttd&&void 0!==e.ttd);if(c>=0)throw Error("More than one merge hardforks found with ttd specified");let d=n.findIndex(e=>null!==e.block&&e.block>i||void 0!==s&&Number(e.timestamp)>s);if(-1===d)d=n.length;else if(0===d)throw Error("Must have at least one hardfork at block 0");if(void 0===s){const e=n.slice(0,d).reverse().findIndex(e=>null!==e.block||void 0!==e.ttd);d-=e}if(d-=1,null===n[d].block&&void 0===n[d].timestamp)(void 0===r||null===r||BigInt(n[d].ttd)>r)&&(d-=1);else if(a>=0&&void 0!==r&&null!==r){if(d>=a&&BigInt(n[a].ttd)>r)throw Error("Maximum HF determined by total difficulty is lower than the block number HF");if(d<a&&BigInt(n[a].ttd)<=r)throw Error("HF determined by block number is lower than the minimum total difficulty HF")}const h=d;for(;d<n.length-1;d+=1)if(n[d].block!==n[d+1].block||n[d].timestamp!==n[d+1].timestamp)break;if(s){const e=n.slice(0,h).reduce((e,t)=>{var o;return Math.max(Number(null!==(o=t.timestamp)&&void 0!==o?o:"0"),e)},0);if(e>s)throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");const t=n.slice(d+1).reduce((e,t)=>{var o;return Math.min(Number(null!==(o=t.timestamp)&&void 0!==o?o:s),e)},s);if(t<s)throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")}const l=n[d];return l.name}setHardforkByBlockNumber(e,t,o){const i=this.getHardforkByBlockNumber(e,t,o);return this.setHardfork(i),i}_getHardfork(e){const t=this.hardforks();for(const o of t)if(o.name===e)return o;return null}setEIPs(e=[]){for(const t of e){if(!(t in ve))throw new Error(`${t} not supported`);const o=this.gteHardfork(ve[t].minimumHardfork);if(!o)throw new Error(`${t} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${o}`);if(void 0!==ve[t].requiredEIPs)for(const i of ve[t].requiredEIPs)if(!e.includes(i)&&!this.isActivatedEIP(i))throw new Error(`${t} requires EIP ${i}, but is not included in the EIP list`)}this._eips=e}param(e,t){let o;for(const i of this._eips)if(o=this.paramByEIP(e,t,i),void 0!==o)return o;return this.paramByHardfork(e,t,this._hardfork)}paramByHardfork(e,t,o){let i=null;for(const r of this.HARDFORK_CHANGES){if("eips"in r[1]){const o=r[1].eips;for(const r of o){const o=this.paramByEIP(e,t,r);i="bigint"===typeof o?o:i}}else{if(void 0===r[1][e])throw new Error(`Topic ${e} not defined`);void 0!==r[1][e][t]&&(i=r[1][e][t].v)}if(r[0]===o)break}return BigInt(null!==i&&void 0!==i?i:0)}paramByEIP(e,t,o){if(!(o in ve))throw new Error(`${o} not supported`);const i=ve[o];if(!(e in i))throw new Error(`Topic ${e} not defined`);if(void 0===i[e][t])return;const r=i[e][t].v;return BigInt(r)}paramByBlock(e,t,o,i,r){const s=this.getHardforkByBlockNumber(o,i,r);return this.paramByHardfork(e,t,s)}isActivatedEIP(e){if(this.eips().includes(e))return!0;for(const t of this.HARDFORK_CHANGES){const o=t[1];if(this.gteHardfork(o.name)&&"eips"in o&&o.eips.includes(e))return!0}return!1}hardforkIsActiveOnBlock(e,t){const o=z(t,k.BigInt),i=null!==e&&void 0!==e?e:this._hardfork,r=this.hardforkBlock(i);return"bigint"===typeof r&&r!==BigInt(0)&&o>=r}activeOnBlock(e){return this.hardforkIsActiveOnBlock(null,e)}hardforkGteHardfork(e,t){const o=null!==e&&void 0!==e?e:this._hardfork,i=this.hardforks();let r=-1,s=-1,n=0;for(const a of i)a.name===o&&(r=n),a.name===t&&(s=n),n+=1;return r>=s&&-1!==s}gteHardfork(e){return this.hardforkGteHardfork(null,e)}hardforkBlock(e){var t;const o=null!==e&&void 0!==e?e:this._hardfork,i=null===(t=this._getHardfork(o))||void 0===t?void 0:t.block;return void 0===i||null===i?null:BigInt(i)}hardforkTimestamp(e){var t;const o=null!==e&&void 0!==e?e:this._hardfork,i=null===(t=this._getHardfork(o))||void 0===t?void 0:t.timestamp;return void 0===i||null===i?null:BigInt(i)}eipBlock(e){for(const t of this.HARDFORK_CHANGES){const o=t[1];if("eips"in o&&o.eips.includes(e))return this.hardforkBlock("number"===typeof t[0]?String(t[0]):t[0])}return null}hardforkTTD(e){var t;const o=null!==e&&void 0!==e?e:this._hardfork,i=null===(t=this._getHardfork(o))||void 0===t?void 0:t.ttd;return void 0===i||null===i?null:BigInt(i)}isHardforkBlock(e,t){const o=z(e,k.BigInt),i=null!==t&&void 0!==t?t:this._hardfork,r=this.hardforkBlock(i);return"bigint"===typeof r&&r!==BigInt(0)&&r===o}nextHardforkBlockOrTimestamp(e){var t,o,i;const r=null!==(t=e)&&void 0!==t?t:this._hardfork,s=this.hardforks();let n=s.findIndex(e=>e.name===r);if(r===g.Merge&&(n-=1),n<0)return null;let a=null!==(o=s[n].timestamp)&&void 0!==o?o:s[n].block;a=null!==a&&void 0!==a?Number(a):null;const c=s.slice(n+1).find(e=>{var t;let o=null!==(t=e.timestamp)&&void 0!==t?t:e.block;return o=null!==o&&void 0!==o?Number(o):null,e.name!==g.Merge&&null!==o&&void 0!==o&&o!==a});if(void 0===c)return null;const d=null!==(i=c.timestamp)&&void 0!==i?i:c.block;return null===d||void 0===d?null:BigInt(d)}nextHardforkBlock(e){var t;const o=null!==(t=e)&&void 0!==t?t:this._hardfork;let i=this.hardforkBlock(o);if(null===i&&o===g.Merge){const e=this.hardforks(),t=e.findIndex(e=>null!==e.ttd&&void 0!==e.ttd);if(t<0)throw Error("Merge hardfork should have been found");i=this.hardforkBlock(e[t-1].name)}if(null===i)return null;const r=this.hardforks().reduce((e,t)=>{const o=BigInt(null===t.block||void 0!==t.ttd&&null!==t.ttd?0:t.block);return o>i&&null===e?o:e},null);return r}isNextHardforkBlock(e,t){const o=z(e,k.BigInt),i=null!==t&&void 0!==t?t:this._hardfork,r=this.nextHardforkBlock(i);return null!==r&&r===o}_calcForkHash(e,t){let o=new Uint8Array,i=0;for(const n of this.hardforks()){const{block:t,timestamp:r,name:s}=n;let c=null!==r&&void 0!==r?r:t;if(c=null!==c?Number(c):null,"number"===typeof c&&0!==c&&c!==i&&s!==g.Merge){const e=(0,a.aT)(c.toString(16).padStart(16,"0"));o=(0,a.cX)(o,e),i=c}if(n.name===e)break}const r=(0,a.cX)(t,o),s=(0,a.My)(B(Me(r)>>>0));return s}forkHash(e,t){const o=null!==e&&void 0!==e?e:this._hardfork,i=this._getHardfork(o);if(null===i||null===(null===i||void 0===i?void 0:i.block)&&void 0===(null===i||void 0===i?void 0:i.timestamp)&&void 0===(null===i||void 0===i?void 0:i.ttd)){const e="No fork hash calculation possible for future hardfork";throw new Error(e)}if(null!==(null===i||void 0===i?void 0:i.forkHash)&&void 0!==(null===i||void 0===i?void 0:i.forkHash))return i.forkHash;if(!t)throw new Error("genesisHash required for forkHash calculation");return this._calcForkHash(o,t)}hardforkForForkHash(e){const t=this.hardforks().filter(t=>t.forkHash===e);return t.length>=1?t[t.length-1]:null}setForkHashes(e){var t;for(const o of this.hardforks()){const i=null!==(t=o.timestamp)&&void 0!==t?t:o.block;null!==o.forkHash&&void 0!==o.forkHash||(null===i||void 0===i)&&"undefined"===typeof o.ttd||(o.forkHash=this.forkHash(o.name,e))}}genesis(){return this._chainParams.genesis}hardforks(){return this._chainParams.hardforks}bootstrapNodes(){return this._chainParams.bootstrapNodes}dnsNetworks(){return this._chainParams.dnsNetworks}hardfork(){return this._hardfork}chainId(){return BigInt(this._chainParams.chainId)}chainName(){return this._chainParams.name}networkId(){return BigInt(this._chainParams.networkId)}eips(){return this._eips}consensusType(){const e=this.hardfork();let t;for(const o of this.HARDFORK_CHANGES)if("consensus"in o[1]&&(t=o[1].consensus.type),o[0]===e)break;return null!==t&&void 0!==t?t:this._chainParams.consensus.type}consensusAlgorithm(){const e=this.hardfork();let t;for(const o of this.HARDFORK_CHANGES)if("consensus"in o[1]&&(t=o[1].consensus.algorithm),o[0]===e)break;return null!==t&&void 0!==t?t:this._chainParams.consensus.algorithm}consensusConfig(){var e;const t=this.hardfork();let o;for(const i of this.HARDFORK_CHANGES)if("consensus"in i[1]&&(o=i[1].consensus[i[1].consensus.algorithm]),i[0]===t)break;return null!==(e=null!==o&&void 0!==o?o:this._chainParams.consensus[this.consensusAlgorithm()])&&void 0!==e?e:{}}copy(){const e=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return e.removeAllListeners(),e}static _getInitializedChains(e){const t={};for(const[i,r]of Object.entries(p))t[r]=i.toLowerCase();const o={mainnet:X,goerli:V,sepolia:K};if(e)for(const i of e){const{name:e}=i;t[i.chainId.toString()]=e,o[e]=i}return o.names=t,o}}var Re;function Ge(e){if(0===e.length)return!0;const t=e[0];return!!Array.isArray(t)}function Ne(e){return!Ge(e)}(function(e){e[e["EIP155ReplayProtection"]=155]="EIP155ReplayProtection",e[e["EIP1559FeeMarket"]=1559]="EIP1559FeeMarket",e[e["EIP2718TypedTransaction"]=2718]="EIP2718TypedTransaction",e[e["EIP2930AccessLists"]=2930]="EIP2930AccessLists"})(Re||(Re={}));class je{constructor(e){if(20!==e.length)throw new Error("Invalid address length");this.buf=e}static zero(){return new je(T(20))}equals(e){return(0,a.X7)(this.buf,e.buf)}isZero(){return this.equals(je.zero())}toString(){return(0,a.My)(this.buf)}toArray(){return this.buf}static publicToAddress(e,t=!1){let o=e;if(_(o),t&&64!==o.length&&(o=h.ProjectivePoint.fromHex(o).toRawBytes(!1).slice(1)),64!==o.length)throw new Error("Expected pubKey to be of length 64");return(0,$.So)(o).slice(-20)}}const ze=(e,t)=>{const o=e.param("vm","maxInitCodeSize");if(o&&BigInt(t)>o)throw new Error(`the initcode size of this transaction is too large: it is ${t} while the max is ${e.param("vm","maxInitCodeSize")}`)},$e=e=>{let t,o;if(Ne(e)){t=e;const i=[];for(let t=0;t<e.length;t+=1){const o=e[t],r=A(o.address),s=[];for(let e=0;e<o.storageKeys.length;e+=1)s.push(A(o.storageKeys[e]));i.push([r,s])}o=i}else{o=null!==e&&void 0!==e?e:[];const i=[];for(let e=0;e<o.length;e+=1){const t=o[e],r=(0,a.My)(t[0]),s=[];for(let e=0;e<t[1].length;e+=1)s.push((0,a.My)(t[1][e]));const n={address:r,storageKeys:s};i.push(n)}t=i}return{AccessListJSON:t,accessList:o}},Ue=e=>{for(let t=0;t<e.length;t+=1){const o=e[t],i=o[0],r=o[1];if(void 0!==o[2])throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(20!==i.length)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let e=0;e<r.length;e+=1)if(32!==r[e].length)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}},qe=e=>{const t=[];for(let o=0;o<e.length;o+=1){const i=e[o],r={address:(0,a.My)(D(i[0],20)),storageKeys:[]},s=i&&i[1];for(let e=0;e<s.length;e+=1){const t=s[e];r.storageKeys.push((0,a.My)(D(t,32)))}t.push(r)}return t},Ve=(e,t)=>{const o=t.param("gasPrices","accessListStorageKeyCost"),i=t.param("gasPrices","accessListAddressCost");let r=0;for(let n=0;n<e.length;n+=1){const t=e[n],o=t[1];r+=o.length}const s=e.length;return s*Number(i)+r*Number(o)};class Xe{constructor(e,t){var o,i;this.cache={hash:void 0,dataFee:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=p.Mainnet,this.DEFAULT_HARDFORK=g.Merge;const{nonce:r,gasLimit:s,to:n,value:a,data:c,v:d,r:h,s:l,type:u}=e;this._type=Number(O(A(u))),this.txOptions=t;const f=A(""===n?"0x":n),m=A(""===d?"0x":d),v=A(""===h?"0x":h),b=A(""===l?"0x":l);this.nonce=O(A(""===r?"0x":r)),this.gasLimit=O(A(""===s?"0x":s)),this.to=f.length>0?new je(f):void 0,this.value=O(A(""===a?"0x":a)),this.data=A(""===c?"0x":c),this.v=m.length>0?O(m):void 0,this.r=v.length>0?O(v):void 0,this.s=b.length>0?O(b):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const y=void 0===this.to||null===this.to,k=null!==(o=t.allowUnlimitedInitCodeSize)&&void 0!==o&&o,I=null!==(i=t.common)&&void 0!==i?i:this._getCommon();y&&I.isActivatedEIP(3860)&&!k&&ze(I,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}validate(e=!1){const t=[];return this.getBaseFee()>this.gasLimit&&t.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),this.isSigned()&&!this.verifySignature()&&t.push("Invalid Signature"),e?t:0===t.length}_validateYParity(){const{v:e}=this;if(void 0!==e&&e!==BigInt(0)&&e!==BigInt(1)){const e=this._errorMsg("The y-parity of the transaction should either be 0 or 1");throw new Error(e)}}_validateHighS(){const{s:e}=this;if(this.common.gteHardfork("homestead")&&void 0!==e&&e>m){const e=this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(e)}}getBaseFee(){const e=this.common.param("gasPrices","tx");let t=this.getDataFee();if(e&&(t+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const e=this.common.param("gasPrices","txCreation");e&&(t+=e)}return t}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),t=this.common.param("gasPrices","txDataNonZero");let o=BigInt(0);for(let i=0;i<this.data.length;i+=1)0===this.data[i]?o+=e:o+=t;if((void 0===this.to||null===this.to)&&this.common.isActivatedEIP(3860)){const e=BigInt(Math.ceil(this.data.length/32)),t=this.common.param("gasPrices","initCodeWordCost")*e;o+=t}return o}toCreationAddress(){return void 0===this.to||0===this.to.buf.length}isSigned(){const{v:e,r:t,s:o}=this;return void 0!==e&&void 0!==t&&void 0!==o}verifySignature(){try{const e=this.getSenderPublicKey();return 0!==M(e).length}catch(e){return!1}}getSenderAddress(){return new je(je.publicToAddress(this.getSenderPublicKey()))}sign(e){if(32!==e.length){const e=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(e)}let t=!1;0===this.type&&this.common.gteHardfork("spuriousDragon")&&!this.supports(Re.EIP155ReplayProtection)&&(this.activeCapabilities.push(Re.EIP155ReplayProtection),t=!0);const o=this.getMessageToSign(!0),{v:i,r,s}=this._ecsign(o,e),n=this._processSignature(i,r,s);if(t){const e=this.activeCapabilities.indexOf(Re.EIP155ReplayProtection);e>-1&&this.activeCapabilities.splice(e,1)}return n}_getCommon(e,t){var o,i,r,s;if(void 0!==t){const o=O(A(t));if(e){if(e.chainId()!==o){const e=this._errorMsg("The chain ID does not match the chain ID of Common");throw new Error(e)}return e.copy()}return Le.isSupportedChainId(o)?new Le({chain:o,hardfork:this.DEFAULT_HARDFORK}):Le.custom({name:"custom-chain",networkId:o,chainId:o},{baseChain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}if((null===e||void 0===e?void 0:e.copy)&&"function"===typeof(null===e||void 0===e?void 0:e.copy))return e.copy();if(e){const t="function"===typeof e.hardfork?e.hardfork():e.hardfork;return Le.custom({name:"custom-chain",networkId:e.networkId?e.networkId():null!==(i=BigInt(null===(o=e.customChain)||void 0===o?void 0:o.networkId))&&void 0!==i?i:void 0,chainId:e.chainId?e.chainId():null!==(s=BigInt(null===(r=e.customChain)||void 0===r?void 0:r.chainId))&&void 0!==s?s:void 0},{baseChain:this.DEFAULT_CHAIN,hardfork:t||this.DEFAULT_HARDFORK})}return new Le({chain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}_validateCannotExceedMaxInteger(e,t=256,o=!1){for(const[i,r]of Object.entries(e))switch(t){case 64:if(o){if(void 0!==r&&r>=l){const e=this._errorMsg(`${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${r}`);throw new Error(e)}}else if(void 0!==r&&r>l){const e=this._errorMsg(`${i} cannot exceed MAX_UINT64 (2^64-1), given ${r}`);throw new Error(e)}break;case 256:if(o){if(void 0!==r&&r>=u){const e=this._errorMsg(`${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${r}`);throw new Error(e)}}else if(void 0!==r&&r>u){const e=this._errorMsg(`${i} cannot exceed MAX_INTEGER (2^256-1), given ${r}`);throw new Error(e)}break;default:{const e=this._errorMsg("unimplemented bits value");throw new Error(e)}}}static _validateNotArray(e){const t=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[o,i]of Object.entries(e))if(t.includes(o)&&Array.isArray(i))throw new Error(`${o} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?(0,a.My)(this.hash()):"not available (unsigned)"}catch(r){e="error"}let t="";try{t=this.isSigned().toString()}catch(r){e="error"}let o="";try{o=this.common.hardfork()}catch(r){o="error"}let i=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return i+=`signed=${t} hf=${o}`,i}_ecsign(e,t,o){const i=h.sign(e,t),r=i.toCompactRawBytes(),s=r.subarray(0,32),n=r.subarray(32,64),a=void 0===o?BigInt(i.recovery+27):BigInt(i.recovery+35)+BigInt(o)*BigInt(2);return{r:s,s:n,v:a}}static fromSerializedTx(e,t={}){}static fromTxData(e,t={}){}}const Ke=2,We=(0,a.aT)(Ke.toString(16).padStart(2,"0"));class Ye extends Xe{static fromTxData(e,t={}){return new Ye(e,t)}static fromSerializedTx(e,t={}){if(!(0,a.X7)(e.subarray(0,1),We))throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${Ke}, received: ${(0,a.My)(e.subarray(0,1))}`);const o=U.Tj.decode(e.subarray(1));if(!Array.isArray(o))throw new Error("Invalid serialized tx input: must be array");return Ye.fromValuesArray(o,t)}static fromValuesArray(e,t={}){if(9!==e.length&&12!==e.length)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[o,i,s,n,a,c,d,h,l,u,f,m]=e;return this._validateNotArray({chainId:o,v:u}),(0,r.M9)({nonce:i,maxPriorityFeePerGas:s,maxFeePerGas:n,gasLimit:a,value:d,v:u,r:f,s:m}),new Ye({chainId:O(o),nonce:i,maxPriorityFeePerGas:s,maxFeePerGas:n,gasLimit:a,to:c,value:d,data:h,accessList:null!==l&&void 0!==l?l:[],v:void 0!==u?O(u):void 0,r:f,s:m},t)}constructor(e,t={}){var o;super(Object.assign(Object.assign({},e),{type:Ke}),t),this.DEFAULT_HARDFORK="london";const{chainId:i,accessList:r,maxFeePerGas:s,maxPriorityFeePerGas:n}=e;if(this.common=this._getCommon(t.common,i),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(1559))throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const a=$e(null!==r&&void 0!==r?r:[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,Ue(this.accessList),this.maxFeePerGas=O(A(""===s?"0x":s)),this.maxPriorityFeePerGas=O(A(""===n?"0x":n)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),Xe._validateNotArray(e),this.gasLimit*this.maxFeePerGas>u){const e=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(e)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const e=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(e)}this._validateYParity(),this._validateHighS();const c=null===(o=null===t||void 0===t?void 0:t.freeze)||void 0===o||o;c&&Object.freeze(this)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(Ve(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(e=BigInt(0)){const t=this.maxPriorityFeePerGas,o=this.maxFeePerGas-e,i=t<o?t:o,r=i+e;return this.gasLimit*r+this.value}raw(){return[R(this.chainId),R(this.nonce),R(this.maxPriorityFeePerGas),R(this.maxFeePerGas),R(this.gasLimit),void 0!==this.to?this.to.buf:Uint8Array.from([]),R(this.value),this.data,this.accessList,void 0!==this.v?R(this.v):Uint8Array.from([]),void 0!==this.r?R(this.r):Uint8Array.from([]),void 0!==this.s?R(this.s):Uint8Array.from([])]}serialize(){const e=this.raw();return(0,a.cX)(We,U.Tj.encode(e))}getMessageToSign(e=!0){const t=this.raw().slice(0,9),o=(0,a.cX)(We,U.Tj.encode(t));return e?(0,$.So)(o):o}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=(0,$.So)(this.serialize())),this.cache.hash):(0,$.So)(this.serialize())}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const e=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(e)}const e=this.getMessageToVerifySignature(),{v:t,r:o,s:i}=this;this._validateHighS();try{return j(e,t+BigInt(27),R(o),R(i))}catch(r){const e=this._errorMsg("Invalid Signature");throw new Error(e)}}_processSignature(e,t,o){const i=Object.assign(Object.assign({},this.txOptions),{common:this.common});return Ye.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:O(t),s:O(o)},i)}toJSON(){const e=qe(this.accessList);return{chainId:L(this.chainId),nonce:L(this.nonce),maxPriorityFeePerGas:L(this.maxPriorityFeePerGas),maxFeePerGas:L(this.maxFeePerGas),gasLimit:L(this.gasLimit),to:void 0!==this.to?this.to.toString():void 0,value:L(this.value),data:(0,a.My)(this.data),accessList:e,v:void 0!==this.v?L(this.v):void 0,r:void 0!==this.r?L(this.r):void 0,s:void 0!==this.s?L(this.s):void 0}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}const Je=1,Qe=(0,a.aT)(Je.toString(16).padStart(2,"0"));class Ze extends Xe{static fromTxData(e,t={}){return new Ze(e,t)}static fromSerializedTx(e,t={}){if(!(0,a.X7)(e.subarray(0,1),Qe))throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${Je}, received: ${(0,a.My)(e.subarray(0,1))}`);const o=U.Tj.decode(Uint8Array.from(e.subarray(1)));if(!Array.isArray(o))throw new Error("Invalid serialized tx input: must be array");return Ze.fromValuesArray(o,t)}static fromValuesArray(e,t={}){if(8!==e.length&&11!==e.length)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[o,i,s,n,a,c,d,h,l,u,f]=e;this._validateNotArray({chainId:o,v:l}),(0,r.M9)({nonce:i,gasPrice:s,gasLimit:n,value:c,v:l,r:u,s:f});const m=[];return new Ze({chainId:O(o),nonce:i,gasPrice:s,gasLimit:n,to:a,value:c,data:d,accessList:null!==h&&void 0!==h?h:m,v:void 0!==l?O(l):void 0,r:u,s:f},t)}constructor(e,t={}){var o;super(Object.assign(Object.assign({},e),{type:Je}),t),this.DEFAULT_HARDFORK="berlin";const{chainId:i,accessList:r,gasPrice:s}=e;if(this.common=this._getCommon(t.common,i),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const n=$e(null!==r&&void 0!==r?r:[]);if(this.accessList=n.accessList,this.AccessListJSON=n.AccessListJSON,Ue(this.accessList),this.gasPrice=O(A(""===s?"0x":s)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),Xe._validateNotArray(e),this.gasPrice*this.gasLimit>u){const e=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(e)}this._validateYParity(),this._validateHighS();const a=null===(o=null===t||void 0===t?void 0:t.freeze)||void 0===o||o;a&&Object.freeze(this)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(Ve(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[R(this.chainId),R(this.nonce),R(this.gasPrice),R(this.gasLimit),void 0!==this.to?this.to.buf:Uint8Array.from([]),R(this.value),this.data,this.accessList,void 0!==this.v?R(this.v):Uint8Array.from([]),void 0!==this.r?R(this.r):Uint8Array.from([]),void 0!==this.s?R(this.s):Uint8Array.from([])]}serialize(){const e=this.raw();return(0,a.cX)(Qe,U.Tj.encode(e))}getMessageToSign(e=!0){const t=this.raw().slice(0,8),o=(0,a.cX)(Qe,U.Tj.encode(t));return e?(0,$.So)(o):o}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=(0,$.So)(this.serialize())),this.cache.hash):(0,$.So)(this.serialize())}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const e=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(e)}const e=this.getMessageToVerifySignature(),{v:t,r:o,s:i}=this;this._validateHighS();try{return j(e,t+BigInt(27),R(o),R(i))}catch(r){const e=this._errorMsg("Invalid Signature");throw new Error(e)}}_processSignature(e,t,o){const i=Object.assign(Object.assign({},this.txOptions),{common:this.common});return Ze.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:O(t),s:O(o)},i)}toJSON(){const e=qe(this.accessList);return{chainId:L(this.chainId),nonce:L(this.nonce),gasPrice:L(this.gasPrice),gasLimit:L(this.gasLimit),to:void 0!==this.to?this.to.toString():void 0,value:L(this.value),data:(0,a.My)(this.data),accessList:e,v:void 0!==this.v?L(this.v):void 0,r:void 0!==this.r?L(this.r):void 0,s:void 0!==this.s?L(this.s):void 0}}errorStr(){var e,t;let o=this._getSharedErrorPostfix();return o+=` gasPrice=${this.gasPrice} accessListCount=${null!==(t=null===(e=this.accessList)||void 0===e?void 0:e.length)&&void 0!==t?t:0}`,o}_errorMsg(e){return`${e} (${this.errorStr()})`}}const et=0;function tt(e,t){const o=Number(e),i=2*Number(t);return o===i+35||o===i+36}class ot extends Xe{static fromTxData(e,t={}){return new ot(e,t)}static fromSerializedTx(e,t={}){const o=U.Tj.decode(e);if(!Array.isArray(o))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(o,t)}static fromValuesArray(e,t={}){if(6!==e.length&&9!==e.length)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[o,i,s,n,a,c,d,h,l]=e;return(0,r.M9)({nonce:o,gasPrice:i,gasLimit:s,value:a,v:d,r:h,s:l}),new ot({nonce:o,gasPrice:i,gasLimit:s,to:n,value:a,data:c,v:d,r:h,s:l},t)}constructor(e,t={}){var o;if(super(Object.assign(Object.assign({},e),{type:et}),t),this.common=this._validateTxV(this.v,t.common),this.gasPrice=O(A(""===e.gasPrice?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>u){const e=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(e)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),Xe._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?tt(this.v,this.common.chainId())&&this.activeCapabilities.push(Re.EIP155ReplayProtection):this.activeCapabilities.push(Re.EIP155ReplayProtection));const i=null===(o=null===t||void 0===t?void 0:t.freeze)||void 0===o||o;i&&Object.freeze(this)}raw(){return[R(this.nonce),R(this.gasPrice),R(this.gasLimit),void 0!==this.to?this.to.buf:Uint8Array.from([]),R(this.value),this.data,void 0!==this.v?R(this.v):Uint8Array.from([]),void 0!==this.r?R(this.r):Uint8Array.from([]),void 0!==this.s?R(this.s):Uint8Array.from([])]}serialize(){return U.Tj.encode(this.raw())}_getMessageToSign(){const e=[R(this.nonce),R(this.gasPrice),R(this.gasLimit),void 0!==this.to?this.to.buf:Uint8Array.from([]),R(this.value),this.data];return this.supports(Re.EIP155ReplayProtection)&&(e.push(A(this.common.chainId())),e.push(M(A(0))),e.push(M(A(0)))),e}getMessageToSign(e=!0){const t=this._getMessageToSign();return e?(0,$.So)(U.Tj.encode(t)):t}getDataFee(){return this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork()?this.cache.dataFee.value:(Object.isFrozen(this)&&(this.cache.dataFee={value:super.getDataFee(),hardfork:this.common.hardfork()}),super.getDataFee())}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=(0,$.So)(U.Tj.encode(this.raw()))),this.cache.hash):(0,$.So)(U.Tj.encode(this.raw()))}getMessageToVerifySignature(){if(!this.isSigned()){const e=this._errorMsg("This transaction is not signed");throw new Error(e)}const e=this._getMessageToSign();return(0,$.So)(U.Tj.encode(e))}getSenderPublicKey(){const e=this.getMessageToVerifySignature(),{v:t,r:o,s:i}=this;this._validateHighS();try{return j(e,t,R(o),R(i),this.supports(Re.EIP155ReplayProtection)?this.common.chainId():void 0)}catch(r){const e=this._errorMsg("Invalid Signature");throw new Error(e)}}_processSignature(e,t,o){let i=e;this.supports(Re.EIP155ReplayProtection)&&(i+=this.common.chainId()*BigInt(2)+BigInt(8));const r=Object.assign(Object.assign({},this.txOptions),{common:this.common});return ot.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:i,r:O(t),s:O(o)},r)}toJSON(){return{nonce:L(this.nonce),gasPrice:L(this.gasPrice),gasLimit:L(this.gasLimit),to:void 0!==this.to?this.to.toString():void 0,value:L(this.value),data:(0,a.My)(this.data),v:void 0!==this.v?L(this.v):void 0,r:void 0!==this.r?L(this.r):void 0,s:void 0!==this.s?L(this.s):void 0}}_validateTxV(e,t){let o;const i=void 0!==e?Number(e):void 0;if(void 0!==i&&i<37&&27!==i&&28!==i)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`);if(void 0!==i&&0!==i&&(!t||t.gteHardfork("spuriousDragon"))&&27!==i&&28!==i)if(t){if(!tt(BigInt(i),t.chainId()))throw new Error(`Incompatible EIP155-based V ${i} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let e;e=(i-35)%2===0?35:36,o=BigInt(i-e)/BigInt(2)}return this._getCommon(t,o)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}const it=new Map;class rt{constructor(){}static typeToInt(e){return Number(O(A(e)))}static registerTransactionType(e,t){const o=rt.typeToInt(e);it.set(o,t)}static fromTxData(e,t={}){if(!("type"in e)||void 0===e.type)return ot.fromTxData(e,t);const o=rt.typeToInt(e.type);if(0===o)return ot.fromTxData(e,t);if(1===o)return Ze.fromTxData(e,t);if(2===o)return Ye.fromTxData(e,t);const i=it.get(o);if(null===i||void 0===i?void 0:i.fromTxData)return i.fromTxData(e,t);throw new Error(`Tx instantiation with type ${o} not supported`)}static fromSerializedData(e,t={}){if(!(e[0]<=127))return ot.fromSerializedTx(e,t);switch(e[0]){case 1:return Ze.fromSerializedTx(e,t);case 2:return Ye.fromSerializedTx(e,t);default:{const o=it.get(Number(e[0]));if(null===o||void 0===o?void 0:o.fromSerializedTx)return o.fromSerializedTx(e,t);throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}}}static fromBlockBodyData(e,t={}){if((0,a.mg)(e))return this.fromSerializedData(e,t);if(Array.isArray(e))return ot.fromValuesArray(e,t);throw new Error("Cannot decode transaction: unknown type input")}}const st=(e,t)=>{let o;if(!t&&"string"===typeof e&&(0,r.lX)(e)&&66!==e.length)throw new n.VJv;try{o=(0,a.mg)(e)?e:(0,a.E3)(e)}catch(s){throw new n.CGi}if(!t&&32!==o.byteLength)throw new n.VJv;return o},nt=(e,t=!1)=>{const o=(0,r.lX)(e)?e:(0,a.Yf)(e),i=(0,a.aT)(o),s=(0,a.aT)((0,a.ar)(`Ethereum Signed Message:\n${i.byteLength}`)),n=t?i:(0,a.cX)(s,i);return(0,a.aQ)(n)},at=(e,t)=>{const o=st(t),i=h.sign(e.substring(2),o),r=i.toCompactRawBytes(),s=i.r.toString(16).padStart(64,"0"),n=i.s.toString(16).padStart(64,"0"),c=i.recovery+27;return{messageHash:e,v:(0,a.cK)(c),r:`0x${s}`,s:`0x${n}`,signature:`${(0,a.My)(r)}${c.toString(16)}`}},ct=(e,t)=>{const o=nt(e),{messageHash:i,v:r,r:s,s:n,signature:a}=at(o,t);return{message:e,messageHash:i,v:r,r:s,s:n,signature:a}},dt=e=>{const t=st(e),o=h.getPublicKey(t,!1),i=(0,a.aQ)(o.slice(1)),r=i.slice(-40);return(0,a.BA)(`0x${r}`)},ht=(e,t)=>{const o=st(e);return`0x${(0,a.My)(h.getPublicKey(o,t)).slice(4)}`}}}]);